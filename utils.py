import shutil
from pathlib import Path
from typing import List, Optional

import astropy.units as u
import numpy as np
from astropy.io import fits
from matadrs.utils.plot import Plotter
from ppdmod.utils import opacity_to_matisse_opacity


def load_flux_model(flux_file: Path) -> np.ndarray:
    """Loads the flux models generated by RvB's code."""
    return np.loadtxt(flux_file, comments="#", unpack=True)[:2]


def get_model_flux(wavelength: np.ndarray, flux_file: Path) -> np.ndarray:
    """Bins the model flux to match the data."""
    model_wl, model_flux = load_flux_model(flux_file)
    return opacity_to_matisse_opacity(
            wavelength*u.um, wavelength_grid=model_wl*u.um,
            opacity=model_flux*u.Jy).value*u.Jy


def average_total_flux(directory: Optional[Path] = None, **kwargs) -> None:
    """Averages toegether the fluxes for the 'mat_tools' reduction."""
    directory = Path.cwd() if directory is None else Path(directory)
    flux_dir = directory / "flux"
    if not flux_dir.exists():
        flux_dir.mkdir(parents=True)
    for fits_file in list(directory.glob("*.fits")):
        new_file = flux_dir / f"{fits_file.stem}_flux_avg.fits"
        shutil.copy(fits_file, new_file)
        with fits.open(new_file, "update") as hdul:
            oi_flux = hdul["oi_flux"].data
            flux, fluxerr = oi_flux["fluxdata"], oi_flux["fluxerr"]
            avg_flux = np.mean(flux, axis=0)
            avg_fluxerr = np.sqrt(np.hypot(np.nanstd(flux, axis=0),
                                           np.nanmean(fluxerr, axis=0)))
            hdul["oi_flux"].data = hdul["oi_flux"].data[:1]
            hdul["oi_flux"].data["fluxdata"] = avg_flux
            hdul["oi_flux"].data["fluxerr"] = avg_fluxerr
            hdul.flush()
        plot = Plotter(new_file, save_path=new_file.parent)
        unwrap = True if "AQUARIUS" in fits_file.name else False
        plot.add_mosaic(unwrap=unwrap).plot(**kwargs)


def remove_flawed_telescope(fits_file: Path, telescopes: List[str],
                            **kwargs) -> None:
    """Removes the data from one or more telescopes via their names.

    Parameters
    ----------
    fits_file : pathlib.Path
        The file to remove the data from.
    telescopes : list of str
        The names of the telescopes to remove the data from.
    """
    new_file = fits_file.parent / f"{fits_file.stem}_{'-'.join(telescopes)}_removed.fits"
    shutil.copy(fits_file, new_file)
    with fits.open(new_file, "update") as hdul:
        sta_indices = dict(zip(hdul["oi_array"].data["tel_name"],
                               hdul["oi_array"].data["sta_index"]))
        for telescope in telescopes:
            sta_index = sta_indices[telescope]
            for entry in hdul:
                if entry.data is None:
                    continue
                if "STA_INDEX" not in entry.columns.names:
                    continue
                data = entry.data["sta_index"]
                if len(data.shape) == 1:
                    mask = data != sta_index
                    entry.data = entry.data[mask]
                else:
                    mask = np.any(data == sta_index, axis=1)
                    entry.data = entry.data[~mask]
        hdul.flush()
    plot = Plotter(new_file, save_path=fits_file.parent)
    unwrap = True if "AQUARIUS" in new_file.name else False
    plot.add_mosaic(unwrap=unwrap).plot(**kwargs)


def replace_data(file: Path,
                 file_for_replace: Path,
                 header: str, sub_headers: List[str]) -> None:
    """Replaces some data of a specific header and sub headers
    of file with the same of a different file.

    Useful when one part of data is corrupted, but all needs to be fitted.
    """
    with fits.open(file_for_replace) as hdul:
        data_to_inject = hdul[header].data

    with fits.open(file, "update") as hdul:
        data = hdul[header].data
        header = hdul[header].header
        if "INJECT" in header:
            print("[SKIPPING]: There is already data"
                  f"injected from another file for the '{header}' header.")
            return
        for sub_header in sub_headers:
            data[sub_header] = data_to_inject[sub_header]
        header["INJECT"] = f"Data injected from {file_for_replace.name}"
        hdul.flush()
